--proc 1: checked
create or REPLACE PROCEDURE add_employees (name text, phone text, email text, address text, full_or_part text, salary_info integer,  join_date date, category text, course_areas text[]) 
AS $$
DECLARE 
	temp_eid INTEGER;
	eid INTEGER;
	course_area text;
BEGIN
	-- category must be legal
	if not (category in ('administrator', 'manager', 'instructor')) then
		raise exception 'Category should be within (administrator, manager, and instructor).';
	end if;
                         
	-- admin has no course_area
	if (category = 'administrator' and course_areas is not null) then
		raise exception 'Administrators do not have course areas.';
	end if;
			     
	-- instructor has course_area
	if (category = 'instructor' and course_areas is null) then
		raise exception 'Instructors should have course areas.';
	end if;
		
	-- manager and admin must be full-time, i.e. monthly paid                                           
	if ((category = 'manager' or category = 'administrator') and (full_or_part <> 'full-time')) then
		raise exception 'Managers and administrators are full-time employees, thus they must be paid monthly.';
	end if;                          
                                                                  
	select max(employees.eid) into temp_eid from employees;
	if temp_eid is NULL then
		eid := 1;
	else eid := temp_eid + 1;
	end if;

	insert into employees values (eid, name, phone, email, address, join_date);
                                                                  
	if full_or_part = 'part-time' then -- this is a part-time employee
		insert into part_time_emp values (eid, salary_info);
		insert into instructors values (eid);
		insert into part_time_instructors values (eid);
                                                 
	elsif full_or_part = 'full-time' then -- this is a full-time employee
		insert into full_time_emp values (salary_info, eid);
	end if;
                                                 
	if category = 'instructor' then 
		insert into instructors values(eid);
		if full_or_part = 'full-time' then
			insert into full_time_instructors values(eid);
		end if;
		FOREACH course_area IN ARRAY course_areas loop
            			INSERT INTO specializes VALUES (eid, course_area);
        		END LOOP;

	elsif category = 'administrator' then
		insert into administrators values(eid);

	elsif category = 'manager' then		
		insert into managers values (eid);
		FOREACH course_area IN ARRAY course_areas LOOP
            			UPDATE course_areas SET eid = eid WHERE name = course_area;
        		END LOOP;
	end if;
END;
$$ LANGUAGE plpgsql;
--proc 2: checked
CREATE OR REPLACE PROCEDURE remove_employee (
    this_eid INTEGER, departure_date DATE
)
AS $$
BEGIN
	-- there are 3 cases when the removal should be rejected
	-- check all 3 cases before proceeding
    if exists (
        select 1
        from Offerings O
        where O.administrator = this_eid and O.registration_deadline > departure_date
    ) then 
    	raise exception 'registration_deadline > departure_date';
    end if;
   
    if exists (
        select 1 
        from Sessions S
        where S.instructor = this_eid and S.launch_date > departure_date 
    ) then 
     	raise exception 'launch_date > departure_date';
     end if;
    
    if exists (
        select 1 
        from Course_areas C
        where C.manager_eid = this_eid -- C.eid is the eid of the manager who is in charge of the course area
    ) then
        raise exception 'in charge of some course areas';
    end if;
   
    update Employees
    set depart_date = departure_date
    where eid = this_eid;
   
   delete from instructors
   where eid = this_eid;
  
	delete from managers
    where eid = this_eid;
   
   delete from administrators
   where eid = this_eid;
  
  delete from full_time_emp
   where eid = this_eid;
  
  delete from part_time_emp
   where eid = this_eid;
END;
$$ LANGUAGE plpgsql;

-- proc 3. checked
-- add_customer: This routine is used to add a new customer. The inputs to the routine include the following: 
-- name, home address, contact number, email address, and credit card details (credit card number, expiry date, CVV code). 
-- The customer identifier is generated by the system.

CREATE OR REPLACE PROCEDURE add_customer (
  _name TEXT,
  _address TEXT,
  _phone TEXT,
  _email TEXT,
  _card_number TEXT,
  _expiry_date DATE,
  _cvv INTEGER
) AS $$

DECLARE
  new_cust_id INTEGER;
  
BEGIN
  SELECT COALESCE (MAX( cust_id ), 0) + 1 INTO new_cust_id from Customers;
  insert into Customers values (new_cust_id, _name, _address, _phone, _email);
  insert into Credit_cards values (new_cust_id, _card_number, _cvv, _expiry_date, CURRENT_DATE);
  
END;
$$ LANGUAGE plpgsql;


-- CALL add_customer ('hty','utr','8008208820','hty@email','400800','2021-05-04',999);


-- proc 4. checked
-- update_credit_card: This routine is used when a customer requests to change his/her credit card details. 
-- The inputs to the routine include the customer identifier and his/her new credit card details (credit card number, expiry date, CVV code).

CREATE OR REPLACE PROCEDURE update_credit_card (
  _cust_id INT,
  _card_number TEXT,
  _expiry_date DATE,
  _cvv INT
) AS $$

BEGIN
  if _cust_id NOT IN (select cust_id from Customers) then
    raise exception 'You need to add Customer % first.', cust_id;
  end if;
  
  if _card_number NOT IN (select card_number from Credit_cards) then
    INSERT INTO Credit_cards VALUES (_cust_id, _card_number, _cvv, _expiry_date, CURRENT_DATE);
  else
    update credit_cards
    set card_number = _card_number, expiry_date = _expiry_date, cvv = _cvv, from_date = CURRENT_DATE
    where cust_id = _cust_id;
  end if;
  
END;
$$ LANGUAGE plpgsql;

CALL update_credit_card (31, 'new_card', '2022-02-02', 888);				  
						  					  
--proc 5: checked
CREATE OR REPLACE PROCEDURE add_course (title VARCHAR(50), description TEXT, area VARCHAR(50), duration INTEGER)
AS $$
DECLARE 
    cid INTEGER; 
BEGIN
    IF (area NOT IN (SELECT name FROM course_areas)) THEN
        raise exception 'Invalid course area.';
    END IF;
    -- If courses is not empty, cid = MAX(course_id) + 1
    -- If no records, initialise cid to be 1
    SELECT COALESCE(MAX(course_id), 0) + 1  INTO cid FROM courses;
	INSERT INTO courses VALUES (cid, title, description, duration, area);
	
END;
$$ LANGUAGE plpgsql;					  
						  
--proc 6
CREATE OR REPLACE FUNCTION find_instructors (cid INTEGER, session_date DATE, session_start_time NUMERIC)
RETURNS TABLE (eid INTEGER, name TEXT) AS $$ 
DECLARE
    curs CURSOR FOR (
        SELECT t.eid, t.name, t.area
        FROM (instructors NATURAL JOIN specializes natural join employees) t
    ); 
    r RECORD;
    ca TEXT; -- ca: course area
    duration NUMERIC;
    session_end_time NUMERIC;
    total_hours NUMERIC;
BEGIN 
    SELECT c.area, c.duration INTO ca, duration FROM courses c WHERE course_id = cid;
    session_end_time := session_start_time + duration;
    OPEN curs; 
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        SELECT SUM(end_time - start_time) INTO total_hours
            FROM Sessions 
            WHERE eid = r.eid 
            AND extract(month from date) = extract(month from session_date); --sum up the hours in that month

          IF r.area = ca
	AND NOT EXISTS (
                SELECT 1 FROM Sessions
                WHERE eid = r.eid
                AND date = session_date
                AND ((start_time between session_start_time and session_end_time + 1) or (end_time between session_start_time - 1 and session_end_time))
            )
	and ((total_hours + duration) <= 30 or (total_hours is null))
            
        THEN
            eid := r.eid;
            name := r.name;
            RETURN NEXT;
        END IF;
    END LOOP; 
    CLOSE curs;
END;
$$ LANGUAGE plpgsql;

						  
--proc 7
CREATE OR REPLACE FUNCTION find_available_instructors (cid INTEGER, start_date DATE, end_date DATE)
RETURNS TABLE (eid INT, name TEXT, hours INT, day DATE, available_hours_this_instructor INT[]) AS $$
declare
	curs_instructors cursor for (select e.eid, e.name, s.area
		from instructors i natural join employees e natural join specializes s
		order by e.eid);
	curs_dates cursor for (SELECT t.day::date 
		FROM generate_series(start_date, end_date, interval  '1 day') AS t(day));
	r_instructor RECORD;
	r_date RECORD;
	total_hours int;
	curr_hour int;
	area text;
	duration int;
	available_hours int[];
begin
	select c.area, c.duration into area, duration from Courses c where course_id = cid;
	open curs_instructors;
	
	loop
		fetch curs_instructors into r_instructor;
		exit when not found;
		if r_instructor.area = area then -- can teach this area
			open curs_dates;
			loop				
				fetch curs_dates into r_date;
				exit when not found;
				select sum(end_time - start_time) into total_hours
				from sessions s
				where s.instructor = r_instructor.eid
				and extract(month from s.date) = extract(month from r_date.day);
				
				if total_hours + duration <= 30 or total_hours is null then -- can teach this month
					-- look for available hours today
					curr_hour := 9; -- earliest session is 9am
					available_hours := '{}';
					loop
						exit when curr_hour >= 18; -- all sessions must end by 18:00
						if curr_hour <> 12 and curr_hour <> 13 then -- no sessions are conducted between 12pm to 2pm
							if NOT EXISTS ( -- can teach at this time
								SELECT 1 
								FROM Sessions s
								WHERE eid = r_instructor.eid
								AND date = r_date.day
								AND ((curr_hour between s.start_time and s.end_time + 1) or ((curr_hour + duration) between s.start_time - 1 and s.end_time) or (curr_hour between 12 and 14) or (curr_hour + duration between 12 and 14))
							) then 
								available_hours := available_hours || curr_hour;
							end if;
						end if;
						curr_hour := curr_hour + 1;
			        end loop; -- found all available hours on this day
			        available_hours_this_instructor := available_hours;
			        eid := r_instructor.eid;
			        name := r_instructor.name;
			        if total_hours is null then hours := 0;
			        else hours := total_hours;
		                        end if;
			        day := r_date.day;
					return next;
				end if;
			end loop; -- found all available times for this instructor
	       		close curs_dates;
		end if;
	end loop; -- found all available instructors
	close curs_instructors;
end;
$$ LANGUAGE plpgsql;

	       
--proc 8: checked		     
CREATE OR REPLACE FUNCTION find_rooms (session_date DATE, start_timing INTEGER , duration INTEGER)
RETURNS TABLE (rid INTEGER) AS $$
DECLARE
    curs CURSOR FOR (SELECT * FROM rooms);
    r RECORD;
    end_timing INTEGER; 
BEGIN
    end_timing := start_timing + duration;
    IF NOT ((start_timing >= 9 and end_timing <= 12) or (start_timing >= 14 and end_timing <= 18)) THEN
        raise exception 'Invalid timing.';
    END IF;

    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        IF NOT EXISTS (
            SELECT 1 FROM sessions S
            WHERE ((S.start_time <= start_timing and start_timing < S.end_time) or (S.start_time < end_timing and end_timing <= S.end_time))
            and (S.rid = r.rid) and (session_date = date) 
            -- seating capacity is yet to check
        ) THEN
            rid := r.rid; 
            RETURN NEXT;
        END IF;
    END LOOP;
    CLOSE curs;
    
END;
$$ LANGUAGE plpgsql;

--proc 9: checked
CREATE OR REPLACE FUNCTION get_available_rooms (start_date DATE, end_date DATE)
RETURNS TABLE (rid INTEGER, capacity INTEGER, day DATE, available_hours INTEGER[]) AS $$
DECLARE
    curs CURSOR FOR (SELECT * FROM rooms ORDER BY rid);
    r RECORD;
    d DATE; 
    h INTEGER;
    hours INTEGER[];
BEGIN
    IF (start_date > end_date) THEN
        raise exception 'Invalid input.';
    END IF;

    OPEN curs;
    -- For each room
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        rid := r.rid;
        capacity := r.seating_capacity;
        
        d := start_date;
        -- For each date in range 
        LOOP
            EXIT WHEN d > end_date;
            h := 9;
            hours := '{}';
            -- For every hour 
            LOOP 
                EXIT WHEN h >= 18;
                IF ((h >= 9 and h < 12) or (h >= 14 and h < 18))
                    and NOT EXISTS (
                        SELECT 1 FROM sessions S
                        WHERE (S.rid = r.rid) and (d = S.date) 
                        and ((S.start_time < h and S.end_time > h) or S.start_time = h))
                THEN
                    hours := hours || h;
                END IF;
                h := h + 1;
            END LOOP;
            day := d;
            available_hours := hours;
            RETURN NEXT;
            d := DATEADD(day, 1, d); -- ??Qn?? Not sure
        END LOOP;
    END LOOP;
    CLOSE curs;
    
END;
$$ LANGUAGE plpgsql;

					    
					    
-- proc 10: checked
-- Here, the input course offering identifier represents a course_id and a launch_date for a course offering
CREATE OR REPLACE PROCEDURE add_course_offering (cid INTEGER, fees FLOAT, 
launch_date DATE, ddl DATE, target_no INTEGER, administrator INTEGER, session TEXT[][])
AS $$
DECLARE 
    i INTEGER; 
    d DATE;
    h INTEGER;
    room INTEGER;
    start_date DATE;
    end_date DATE;
    total_seating_capacity INTEGER;
    target_number_registrations INTEGER;
    seating_capacity INTEGER;
BEGIN
    i := 1;
    total_seating_capacity := 0;
    LOOP
        EXIT WHEN i > array_length(session, 1);
        d := session[i][1]::DATE;
        h := session[i][2]::INTEGER;
        room := session[i][3]::INTEGER;

        -- Check if there is some instructors available for each session input
        IF EXISTS (SELECT 1 
                    FROM find_instructors(cid, d, h))
        THEN -- if yes, continues with addition
            SELECT R.seating_capacity INTO seating_capacity 
            FROM rooms R 
            WHERE R.rid = room;
            -- total_seating_capacity = sum of capacities of sessions
            total_seating_capacity := total_seating_capacity + seating_capacity;
            -- Here, we want to find the earliest session_date and the latest one
            IF start_date IS NULL
            THEN 
                start_date := d;
            END IF;
            IF end_date IS NULL
            THEN 
                end_date := d;
            END IF;
            
            IF d < start_date 
            THEN 
                start_date := d;
            END IF;
   
            IF d > end_date
            THEN 
                end_date := d;
            END IF;
            
        ELSE -- if no, then abort
             RAISE EXCEPTION 'The course offering addition is aborted, because one or some of the sessions do not have an available instructor';
        END IF;
        i := i + 1;
    END LOOP;
    target_number_registrations := target_no;
    
    IF (start_date - ddl >= 10) THEN
        raise exception 'Registration deadline for a course offering must be at least 10 days before its start date.';
    END IF;
    IF (cid, launch_date) IN (SELECT S.course_id, S.launch_date FROM Offerings S)
    THEN
        d := launch_date;
        DELETE FROM Offerings O
        WHERE O.course_id = cid and O.launch_date = d;
    END IF;
    INSERT INTO Offerings VALUES(cid, launch_date, start_date, end_date, fees, ddl, target_number_registrations, total_seating_capacity, administrator);

END;
$$ LANGUAGE plpgsql;
					    
					    
   				    

--proc 11 checked
CREATE OR REPLACE PROCEDURE add_course_package(name TEXT, num_free_sessions INTEGER, start_date DATE, end_date DATE, price FLOAT)
AS $$
DECLARE
    cpid INTEGER;
BEGIN
    SELECT COALESCE(MAX(package_id), 0) + 1 INTO cpid FROM Course_packages;
    INSERT INTO Course_packages VALUES (cpid, name, start_date, end_date, num_free_sessions, price);
END;
$$ LANGUAGE plpgsql;

-- proc 12 checked
CREATE OR REPLACE FUNCTION get_available_course_packages()
RETURNS TABLE (name TEXT, num_free_sessions INTEGER, sale_end_date DATE, price FLOAT) AS $$
DECLARE
    curr_date DATE;
    curs CURSOR FOR (SELECT * FROM Course_packages);
    rcd RECORD;
BEGIN
    SELECT CURRENT_DATE INTO curr_date;
    OPEN curs;
    LOOP
        FETCH curs INTO rcd;
        EXIT WHEN NOT FOUND;
        IF curr_date >= rcd.sale_start_date AND curr_date <= rcd.sale_end_date 
        THEN
            name := rcd.name;
            num_free_sessions := rcd.num_free_registrainons;
            sale_end_date := rcd.sale_end_date;
            price := rcd.price;
            RETURN NEXT;
        END IF;
    END LOOP;
    CLOSE curs;
END;
$$ LANGUAGE plpgsql;
	
-- proc 13
create or replace function buy_course_package(cust_id_input integer, cp_id_input integer)
returns table(today date, var_cust_id integer, var_card_number integer, var_cp_id integer, remaining_redemptions integer) AS $$
BEGIN
-- check whether the customer has a credit card
if not exists (
select 1
from owns
where cust_id = cust_id_input
) then raise exception 'this customer has no credit card';
end if;

-- check if this cutomer has any other active packages
if exists (
select 1
from buys 
where cust_id = cust_id_input and num_remaining_redemptions > 0
) then raise exception 'this customer has other active packages';
end if;  

-- now, this transaction is valid
-- do the transaction
var_cust_id := cust_id_input;
var_cp_id := cp_id_input;
SELECT NOW()::date into today;
select num_free_registrations into remaining_redemptions
from course_packages
where package_id = cp_id_input;
select card_number into var_card_number
from owns
where cust_id = cust_id_input;

insert into buys(date, num_remaining_redemptions, package_id, card_number, cust_id) values (today, remaining_redemptions, cp_id_input, var_card_number, cust_id_input);
return next;
END;                
$$ LANGUAGE plpgsql;

--proc 14 debugged&checked hty
CREATE OR REPLACE FUNCTION get_my_course_package (_cust_id INTEGER)
RETURNS JSON AS
$$
DECLARE
    pkg_id INTEGER;
    pkg_name TEXT;
    purchase_date DATE;
    pkg_price FLOAT;
    num_unredeemed_sessions INTEGER;
    num_free_sessions INTEGER;
    redeemed_sessions_info JSON;

BEGIN
    SELECT B.package_id, B.num_remaining_redemptions, B.date INTO pkg_id, num_unredeemed_sessions, purchase_date
    FROM Buys B
    WHERE B.cust_id = _cust_id
    ORDER BY B.date DESC
    LIMIT 1; --latest package of customer
	  
    IF pkg_id IS NOT NULL THEN
        SELECT CP.name, CP.price, CP.num_free_registrations INTO pkg_name, pkg_price, num_free_sessions
        FROM Course_packages CP
        WHERE CP.package_id = pkg_id;
    END IF;

    CREATE TEMP TABLE redeem_info (course_name, session_date, session_start_hour) ON COMMIT DROP AS 
    SELECT  C.title, S.date, S.start_time
    FROM Redeems R, Courses C, Sessions S, Offerings O
    WHERE R.cust_id = _cust_id
          and R.package_id = pkg_id
          and R.buys_date = purchase_date
          and R.sid = S.sid
          and R.launch_date = O.launch_date
          and R.course_id = O.course_id
          and O.course_id = C.course_id;
    SELECT json_agg(redeem_info) INTO redeemed_sessions_info FROM redeem_info;
    RETURN json_build_object('package_name', pkg_name,
                             'buys_date', purchase_date,
                             'price', pkg_price,
                             'num_free_sessions', num_free_sessions,
                             'num_unredeemed_sessions', num_unredeemed_sessions,
                             'redeemed_session_info', redeemed_sessions_info);
END;
$$ LANGUAGE plpgsql;

-- DROP FUNCTION get_my_course_package(int);
-- SELECT get_my_course_package(31);
					 			 					    
-- proc 15: checked
CREATE OR REPLACE FUNCTION get_available_course_offerings (OUT course_title VARCHAR(50), 
OUT course_area VARCHAR(50), OUT start_date DATE, OUT end_date DATE,
OUT registration_deadline DATE, OUT course_fees FLOAT, OUT remaining_seats INTEGER)
RETURNS SETOF RECORD AS $$
BEGIN
    RETURN QUERY(
    SELECT R.title, R.area, R.start_date, R.end_date, R.registration_deadline, 
            R.fees, (R.seating_capacity - R.taken_seats) :: INTEGER AS remaining
    FROM (
        SELECT C.title, C.area, O.start_date, O.end_date, O.registration_deadline, 
                O.fees, O.seating_capacity, (COALESCE(num_redeem, 0) + COALESCE(num_register, 0)) AS taken_seats
        FROM Offerings O NATURAL LEFT JOIN Courses C 
        NATURAL LEFT JOIN 
         (SELECT R1.course_id, R1.launch_date, COUNT(*) AS num_redeem
            FROM redeems R1 
            GROUP BY R1.course_id, R1.launch_date) AS redeem_info
        NATURAL LEFT JOIN
        (SELECT R2.course_id, R2.launch_date, COUNT(*) AS num_register
            FROM registers R2 
            GROUP BY R2.course_id, R2.launch_date) AS register_info
        NATURAL LEFT JOIN
        (SELECT R3.course_id, R3.launch_date, COUNT(*) AS num_cancel
            FROM cancels R3 
            GROUP BY R3.course_id, R3.launch_date) AS cancel_info) AS R
    WHERE  R.seating_capacity - R.taken_seats > 0
    ORDER BY registration_deadline, title
    );
END;
$$ LANGUAGE plpgsql;


				  
--proc 16
CREATE OR REPLACE FUNCTION get_available_course_sessions(course_id_input integer)
RETURNS TABLE(session_date DATE, start_time integer, instructor_name TEXT, number_remaining_seats INTEGER) AS $$   
declare
	curs_session_room cursor for (select s.sid, s.launch_date, s.course_id, s.date, r.seating_capacity, s.start_time, s.date, e.name
		from sessions s, rooms r, employees e
		where s.course_id = course_id_input and s.rid = r.rid and s.instructor = e.eid
		order by date, start_time);
	curs_registers cursor for (select sid, launch_date, course_id
		from registers
		where course_id = course_id_input);
	curs_redeems cursor for (select sid, launch_date, course_id
		from redeems
		where course_id = course_id_input);
	r_session_room RECORD;
	r_registers RECORD;
	r_redeems RECORD;
	available_seats integer;
begin
	open curs_session_room;
	loop -- for each session
		fetch curs_session_room into r_session_room;
		exit when not found;
		available_seats := r_session_room.seating_capacity;

		open curs_registers;
		loop -- loop through registers
			fetch curs_registers into r_registers;
			exit when not found;
			if (r_registers.sid = r_session_room.sid and r_registers.launch_date = r_session_room.launch_date and r_registers.course_id = r_session_room.course_id) then 
				available_seats := available_seats - 1;
			end if;
		end loop;
		close curs_registers;
		
		open curs_redeems;
		loop -- loop through redeems
			fetch curs_redeems into r_redeems;
			exit when not found;
			if (r_redeems.sid = r_session_room.sid and r_redeems.launch_date = r_session_room.launch_date and r_redeems.course_id = r_session_room.course_id) then 
				available_seats := available_seats - 1;
			end if;
		end loop;
		close curs_redeems;
		
		if (available_seats > 0) then
			session_date := r_session_room.date;
			start_time := r_session_room.start_time;
			instructor_name := r_session_room.name;
			number_remaining_seats := available_seats;
			return next;
		end if;
	end loop;
	close curs_session_room;
end;
$$ LANGUAGE plpgsql;
	       
-- 17. register_session:  checked
-- This routine is used when a customer requests to register for a session in a course offering. 
-- The inputs to the routine include the following: customer identifier, course offering identifier, session number,
-- and payment method (credit card or redemption from active package). 
-- If the registration transaction is valid, this routine will process the registration with the necessary updates (e.g., payment/redemption).

-- 1 means using credit_card
-- 2 means using redemption

CREATE OR REPLACE PROCEDURE register_session (
  input_cust_id INT,
  input_course_id INT,
  input_sid INT, -- session id
  input_payment_method INT -- 1 or 2, 1 for register, 2 for redeem
) AS $$
DECLARE
  launchDate DATE;
  buysDate DATE;
  cardNum TEXT;
  pkgID INT;
BEGIN
-- prepare the insert values
  select launch_date into launchDate from Sessions where sid=input_sid;

  select B.date, B.package_id into buysDate, pkgID 
  from Buys B
  where B.cust_id = input_cust_id AND B.num_remaining_redemptions >= 1
  ORDER BY B.num_remaining_redemptions desc
  LIMIT 1; -- select the active package

  select card_number into cardNum from Owns where cust_id = input_cust_id;
-- check if this process valid
  if (input_payment_method !=1 AND input_payment_method !=2) then
    raise exception 'Payment method invalid. Enter 1 for credit_card, 2 for redemption';
  elsif NOT EXISTS (select 1 from Sessions where sid = input_sid and course_id = input_course_id) then
    raise exception 'This session does not exist.';
  elsif NOT EXISTS (select 1 from Customers where cust_id = input_cust_id) then
    raise exception 'You need to add_customer first.';
  elsif pkgID ISNULL then
    raise exception 'Customer has no active package.';
  end if;
-- process regarding payment method
-- payment with credit card, update registers
  if (input_payment_method = 1) then 
-- update registers
    insert into Registers
    values (CURRENT_DATE, cardNum, input_cust_id, input_sid, launchDate, input_course_id);
-- payment by redemption, update redeems & buys
  elsif (input_payment_method = 2) then
-- update redeems    
    insert into Redeems
    values (CURRENT_DATE, input_sid, launchDate, input_course_id, buysDate, cardNum, pkgID, input_cust_id);
-- update buys, set remaining redemptions - 1
    update Buys
    set num_remaining_redemptions = num_remaining_redemptions - 1
    where cust_id = input_cust_id AND package_id = pkgID;
  end if;
END;
$$ LANGUAGE plpgsql;

-- proc 18: checked
CREATE OR REPLACE FUNCTION get_my_registrations(customer_id INTEGER)
RETURNS TABLE(course_name VARCHAR(50), fees FLOAT, session_date DATE, start_hour INTEGER, 
duration INTEGER, instructor_name TEXT) AS $$
DECLARE 
    cur_hour INTEGER;
BEGIN
    IF customer_id NOT IN (SELECT cust_id FROM Customers) THEN
        raise exception 'Customer ID not found, please check your input.';
    END IF;
    
    cur_hour := extract(HOUR FROM CURRENT_TIMESTAMP);
    
    RETURN QUERY(
    SELECT R.title, R.fees, R.date, R.start_time, R.duration, R.name
    FROM (
    (SELECT C.course_id, O.launch_date, S.sid, C.title, C.duration, O.fees, 
            S.date, S.start_time, E.name
      FROM courses C, Offerings O, Sessions S, Employees E 
      WHERE C.course_id = O.course_id and O.course_id = S.course_id 
      and O.launch_date = S.launch_date and S.instructor = E.eid
      and S.date >= CURRENT_DATE) AS session_info
      
    NATURAL LEFT JOIN  
    (SELECT R1.course_id, R1.launch_date, COUNT(*) AS num_redeem, R1.sid
      FROM redeems R1 
      WHERE R1.cust_id = customer_id
      GROUP BY R1.course_id, R1.launch_date, R1.sid) AS redeem_info
      
    NATURAL LEFT JOIN   
    (SELECT R2.course_id, R2.launch_date, COUNT(*) AS num_register, R2.sid
      FROM registers R2 
      WHERE R2.cust_id = customer_id
      GROUP BY R2.course_id, R2.launch_date, R2.sid) AS register_info
      
    NATURAL LEFT JOIN 
    (SELECT R3.course_id, R3.launch_date, COUNT(*) AS num_cancel
      FROM cancels R3 
      WHERE R3.cust_id = customer_id
      GROUP BY R3.course_id, R3.launch_date, R3.sid) AS cancel_info) AS R
      
    WHERE ((CURRENT_DATE < R.date)
    or (CURRENT_DATE = R.date and cur_hour < R.start_time))
    and (COALESCE (num_redeem, 0)+COALESCE (num_register, 0)-COALESCE (num_cancel, 0)) = 1 
    ORDER BY R.date, R.start_time
    );
END;
$$ LANGUAGE plpgsql;
	 
	 

--proc_19
CREATE OR REPLACE PROCEDURE update_course_session(input_cust_id integer, input_cid integer, input_launch_date date, input_new_sid integer)
AS $$
DECLARE 
var_remaining_seating_capacity integer;
var_num_register integer;
var_num_redeem integer;
BEGIN
if not exists (select 1 from registers r where r.cust_id = input_cust_id and r.course_id = input_cid and r.launch_date = input_launch_date) then
raise exception 'This customer has not registered this course offering yet, cannot update.';
end if;
-- now we know that the request is valid
-- check whether the new session is available for this customer
select seating_capacity into var_remaining_seating_capacity from sessions s, rooms r where s.rid = r.rid and s.sid = input_new_sid and s.launch_date = input_launch_date and s.course_id = input_cid;

select count(cust_id) into var_num_register from registers where sid = input_new_sid and launch_date = input_launch_date and course_id = input_cid;
var_remaining_seating_capacity := var_remaining_seating_capacity - var_num_register;
if var_remaining_seating_capacity <= 0 then
raise exception 'The new session is full.';
end if;

select count(cust_id) into var_num_redeem from redeems where sid = input_new_sid and launch_date = input_launch_date and course_id = input_cid;
var_remaining_seating_capacity := var_remaining_seating_capacity - var_num_redeem;
if var_remaining_seating_capacity <= 0 then
raise exception 'The new session is full.';
end if;

-- now we know the new session is available
-- update register and session
update registers set sid = input_sid where cust_id = input_cust_id and launch_date = input_launch_date and course_id = input_cid;
update sessions set seating_capacity = var_remaining_seating_capacity  - 1 where sid = input_sid and launch_date = input_launch_date and course_id = input_cid;

END;
$$ LANGUAGE plpgsql;
	 
--proc_20
CREATE OR REPLACE PROCEDURE cancel_registration(input_cust_id integer, input_cid integer, input_launch_date date)
AS $$
DECLARE 
var_sid integer;
var_session_date date;
today date;
var_package_id integer;
BEGIN
-- fisrt check if the cancellation is valid
if not exists (select 1 from registers r where r.cust_id = input_cust_id and r.course_id = input_cid and r.launch_date = input_launch_date) then
raise exception 'This customer has not registered this course offering yet, cannot cancel.';
end if;

-- begin updating involved tables
select sid into var_sid from registers where course_id = input_cid and launch_date = input_launch_date and cust_id = input_cust_id;
update sessions set seating_capacity = seating_capacity + 1 where sid = var_sid and launch_date = input_launch_date and course_id = input_cid;
select date into var_session_date from sessions where sid = var_sid and launch_date = input_launch_date and course_id = input_cid;

-- check the payment method, if redeemed a package, then add back to the package
if exists (select 1 from redeems where sid = var_sid and launch_date = input_launch_date and course_id = input_cid and cust_id = input_cust_id) then -- redeemed a package
-- check if refund is eligible
SELECT NOW()::date into today;
if var_session_date >= today + 7 then
-- check if the customer has an active package, if so, add one to the package
if exists (select 1 from buys where cust_id = input_cust_id and num_remaining_redemptions > 0) then
update buys set num_remaining_redemptions = num_remaining_redemptions + 1 where cust_id = input_cust_id and num_remaining_redemptions > 0; -- add one to the active package

-- the customer does not have an active package, add one back to the redeemed package
else 
select package_id into var_package_id from redeems where sid = var_sid and launch_date = input_launch_date and course_id = input_cid and cust_id = input_cust_id;
update buys set num_remaining_redemptions = num_remaining_redemptions + 1 where cust_id = input_cust_id and package_id = var_package_id;
end if; -- if has active package

else
raise exception 'Within 7 days of the session date, cannot refund.';
end if; -- if refund is eligible

raise notice 'Paid by credit card, no result will be shown here.';
end if; -- if redeemed a package
END;
$$ LANGUAGE plpgsql;

-- update_instructor: This routine is used to change the instructor for a course session. 
-- The inputs to the routine include the following: course offering identifier, session number, and identifier of the new instructor. 
-- If the course session has not yet started and the update request is valid, the routine will process the request with the necessary updates.

-- proc 21 checked
	 
-- CREATE OR REPLACE FUNCTION find_instructors (cid INTEGER, session_date DATE, session_start_time NUMERIC)
-- RETURNS TABLE (eid INTEGER, name TEXT) AS $$ 

-- 一个测试用的code，测试‘如果要获得时间差，该用哪个减哪个‘
-- CREATE OR REPLACE PROCEDURE greater_date (input_sid INT)
-- AS $$
-- DECLARE
--   compare_date DATE;
-- BEGIN
--   select date into compare_date from Sessions where sid = input_sid;
--   if (CURRENT_DATE - compare_date > 10) then
--     raise notice 'CURRENT_DATE is 10 days greater';
--   else
--     raise notice 'reverse';
--   end if;
-- END;
-- $$ LANGUAGE plpgsql;

CREATE OR REPLACE PROCEDURE update_instructor (_course_id INT, _sid INT, _instructor INT)
AS $$

DECLARE
  session_start_date DATE;
  session_start_time NUMERIC;
BEGIN
  SELECT date, start_time INTO session_start_date, session_start_time FROM Sessions WHERE (course_id = _course_id AND sid = _sid);
  
  if CURRENT_DATE > session_start_date then
    raise exception 'The session has already started.';
  elsif (_instructor NOT IN (SELECT eid FROM find_instructors (_course_id, session_start_date, session_start_time))) then
    raise exception 'This instructor is not avilable to be assigned to this course session.';
  else
    update Sessions
    set instructor = _instructor
    where (course_id = _course_id AND sid = _sid);
  end if;
END;
$$ LANGUAGE plpgsql;

-- original 22
-- CREATE OR REPLACE PROCEDURE update_room(new_cid integer, new_sid integer, new_rid integer)
-- AS $$
-- DECLARE
--     seating_cpct integer;
--     num_register_customers integer;
--     num_redeem_customers integer;
--     total_registered integer;
--     session_date date;
-- BEGIN
--     select seating_capacity into seating_cpct from rooms where rid = new_rid;
--     select date into session_date from sessions where course_id = new_cid and sid = new_sid;
--     select count(distinct cust_id) into num_register_customers from registers where course_id = new_cid;
--     select count(distinct customer_id) into num_redeem_customers from redeems where course_id = new_cid;
--     total_registered := num_register_customers + num_redeem_customers;

--     IF seating_cpct > total_registered and CURRENT_DATE > session_date THEN
--         update sessions
--         set rid = new_rid
--         where course_id = new_cid and sid = new_sid;
--     ELSE 
--         Raise Exception 'Seating capacity/current date mismatch';
--     END IF;
-- END;
-- $$ language plpgsql;

-- proc 22 -checked
-- update_room: This routine is used to change the room for a course session. The inputs to the routine include the following:
--  course offering identifier, session number, and identifier of the new room. 
-- If the course session has not yet started and the update request is valid, 
-- 1. session尚未开始 ok
-- 2. seating_capcaity > num_total 否则坐不下 ok
-- 3. room available 用find_rooms去找可以用的rid ok
-- the routine will process the request with the necessary updates. 
-- Note that update request should not be performed if the number of registrations for the session exceeds the seating capacity of the new room.

-- CREATE OR REPLACE FUNCTION find_rooms (session_date DATE, start_timing INTEGER , duration INTEGER)
-- RETURNS TABLE (rid INTEGER) AS $$

CREATE OR REPLACE PROCEDURE update_room (input_course_id INT, input_sid INT, input_rid INT) -- input_rid is the new room's rid
AS $$
DECLARE
  session_start_date DATE;
  session_start_time INT;
  session_end_time INT;
  session_duration INT;
  num_register INT;
  num_redeem INT;
  num_total INT;
  capacity INT;

BEGIN
  -- preparation
  -- seating capcaity & num of customers registered
  select seating_capacity into capacity from Rooms where rid = input_rid;
  select count(distinct cust_id) into num_register from Registers where course_id = input_course_id AND sid = input_sid;
  select count(distinct cust_id) into num_redeem from Redeems where course_id = input_course_id AND sid = input_sid;
  num_total := num_register + num_redeem;
  -- session_start_date & start_time & duration
  select date, start_time, end_time into session_start_date, session_start_time, session_end_time from Sessions where course_id = input_course_id AND sid = input_sid;
  session_duration := session_end_time - session_start_time;
  
  -- check if the session has already started
  if CURRENT_DATE > session_start_date then
    raise exception 'The session has already started.';
    --raise notice 'The session has already started.'; --因为我们的sessions数据没有大于CURRENT_DATE的session，用raise notice来避免error
  elsif num_total > capacity then
    raise exception 'Num of registered customers exceeds the seating capcity of the new room.';
  elsif input_rid NOT IN (select rid from find_rooms(session_start_date, session_start_time, session_duration)) then
    raise exception 'The room is not available. Use find_rooms(session_date, start_time, duration) to find the available room.';
  end if;
  -- now, the process is valid. Update Sessions rid
  update Sessions
  set rid = input_rid
  where course_id = input_course_id AND sid = input_sid;

END;
$$ LANGUAGE plpgsql;
  


-- original proc 23
-- create or replace procedure remove_session(new_cid integer, new_sid integer)
-- as $$
-- DECLARE
--     num_register_customers integer;
--     num_redeem_customers integer;
--     total_registered integer;
--     session_date date;
-- BEGIN
--     select date into session_date from sessions where course_id = new_cid and sid = new_sid;
--     select count(cust_id) into num_register_customers from registers where course_id = new_cid and sid = new_sid;
--     select count(cust_id) into num_redeem_customers from redeems where course_id = new_cid and sid = new_sid;
--     total_registered := num_register_customers + num_redeem_customers;

--     IF total_registered = 0 and CURRENT_DATE > session_date THEN
--         delete from CourseSessions
--         where course_id = new_cid and sid = new_sid;
--     END IF;
-- END;
-- $$ language plpgsql;

						     
-- proc 23
-- remove_session: This routine is used to remove a course session. 
-- The inputs to the routine include the following: course offering identifier and session number. 
-- If the course session has not yet started and the request is valid, 
-- the routine will process the request with the necessary updates. 
-- The request must not be performed if there is at least one registration for the session. 
-- Note that the resultant seating capacity of the course offering could fall below 
-- the course offering’s target number of registrations, which is allowed.

-- constraints
-- 1. session还没开始， CURRENT_DATE > session_start_date就invalid
-- 2. 没有人register
CREATE OR REPLACE PROCEDURE remove_session (input_course_id INT, input_sid INT)
AS $$

DECLARE
  session_start_date DATE;
  num_register INT;
  num_redeem INT;
  num_total INT;

BEGIN
  -- preparation
  select count(distinct cust_id) into num_register from Registers where course_id = input_course_id AND sid = input_sid;
  select count(distinct cust_id) into num_redeem from Redeems where course_id = input_course_id AND sid = input_sid;
  num_total := num_register + num_redeem;
  select date into session_start_date from Sessions where course_id = input_course_id AND sid = input_sid;
  -- check constraints
  if CURRENT_DATE > session_start_date then
    raise exception 'The session has already started.';
  elsif num_total > 0 then
    raise exception 'There are % customers registered for this session.', num_total;
  end if;
  -- update
  delete from Sessions where course_id = input_course_id AND sid = input_sid;
END;
$$ LANGUAGE plpgsql;

-- proc 24: checked
-- Here, the input course offering identifier represents a course_id and a launch_date for a course offering
CREATE OR REPLACE PROCEDURE add_session (cid INTEGER, launch DATE, sid INTEGER, 
session_date DATE, start_hour INTEGER, instructor INTEGER, room_id INTEGER) AS $$
DECLARE 
    duration INTEGER;
    new_start_date DATE;
    new_end_date DATE;
    ddl DATE;
    new_seating_capacity INTEGER;
    total_seating_capacity INTEGER;
    target_number_registrations INTEGER;
BEGIN 
    SELECT O.start_date, O.end_date, O.registration_deadline, O.target_number_registrations
    INTO new_start_date, new_end_date, ddl, target_number_registrations
    FROM Offerings O
    WHERE O.course_id = cid and O.launch_date = launch;
    
    SELECT C.duration INTO duration FROM Courses C WHERE C.course_id = cid;
    SELECT R.seating_capacity INTO new_seating_capacity FROM Rooms R WHERE R.rid = room_id;
    SELECT SUM(seating_capacity) INTO total_seating_capacity FROM Sessions S WHERE S.course_id = cid and S.launch_date = launch;
    
    IF session_date < new_start_date
    THEN 
        new_start_date := session_date;
    ELSIF session_date > new_end_date
    THEN
        new_end_date := session_date;
    END IF;
    
    -- check constraints
    IF (CURRENT_DATE > ddl)
    THEN
        raise exception 'Course offering’s registration deadline has passed';
    END IF;
    
    IF new_seating_capacity + total_seating_capacity > target_number_registrations
    THEN
        raise exception 'Seating capacity exceeded.';
    END IF;
    
    IF (cid, launch) NOT IN (SELECT O.course_id, O.launch_date FROM Offerings O)
    THEN
        raise exception 'Course offering not found, invalid input';
    END IF;
    
    IF (new_start_date - ddl < 10)
    THEN
        raise exception 'Registration deadline for a course offering must be at least 10 days before its start date.';
    END IF;

	INSERT INTO Sessions VALUES (sid, launch, cid, session_date, start_hour, (start_hour+duration), room_id, new_seating_capacity, instructor);
	-- update offerings's start_date/end_date and seating capacity
	UPDATE Offerings O
	SET start_date = new_start_date, end_date = new_end_date, seating_capacity = new_seating_capacity + total_seating_capacity
	WHERE O.course_id = cid and O.launch_date = launch;
	  
END;
$$ LANGUAGE plpgsql;					     

-- proc 25
-- pay_salary: This routine is used at the end of the month to pay salaries to employees. 
-- The routine inserts the new salary payment records and returns a table of records 
-- (sorted in ascending order of employee identifier) with the following information for each employee who is paid for the month: 
-- employee identifier, name, status (either part-time or full-time), number of work days for the month, number of work hours for the month, 
-- hourly rate, monthly salary, and salary amount paid. For a part-time employees, the values for number of work days for the month and 
-- monthly salary should be null. For a full-time employees, the values for number of work hours for the month and hourly rate should be null.
-- proc 25
create or replace function pay_salary()
returns table(var_eid integer, var_name text, var_status text, var_work_days integer, var_work_hours integer, var_hourly_rate integer, var_monthly_salary integer, var_salary_paid integer) AS $$
DECLARE
curs_emp cursor for (
select eid, name, monthly_salary, hourly_rate, join_date, depart_date
from (employees natural left join part_time_emp) natural left join full_time_emp
where depart_date is null or (depart_date is not null and extract(month from depart_date) = extract(month from CURRENT_DATE))
); -- all employees we need to pay salary to. Since the employees are ordered by eid in the table, hence no need to reorder.
r_emp record;
var_first_day_this_month date;
var_last_day_this_month date;
var_last_work_date date;
var_first_work_date date;
BEGIN
open curs_emp;
loop
fetch curs_emp into r_emp;
exit when not found;
if r_emp.monthly_salary is not null then -- is full-time
var_first_day_this_month := date_trunc('MONTH',now())::DATE;
var_last_day_this_month := (date_trunc('MONTH', now()::date) + INTERVAL '1 MONTH - 1 day')::DATE;
-- get the last working date of this month
if r_emp.depart_date is null then -- end date = last day this month
var_last_work_date := var_last_day_this_month;
else -- end date = depart_date
var_last_work_date := r_emp.depart_date;
end if;
-- get the first working date this month
if r_emp.join_date >= var_first_day_this_month then -- first_work_date = join_date
var_first_work_date := r_emp.join_date;
else -- first_work_date = first day this month
var_first_work_date := var_first_day_this_month;
end if;

-- calculate the salary
var_salary_paid := r_emp.monthly_salary * ((var_last_work_date - var_first_work_date + 1) / (var_last_day_this_month - var_first_day_this_month + 1));
var_eid := r_emp.eid;
var_name := r_emp.name;
var_status := 'full-time';
var_work_days := var_last_work_date - var_first_work_date + 1;
var_work_hours := null;
var_hourly_rate := null;
var_monthly_salary := r_emp.monthly_salary;
insert into pay_slips values (current_date, var_salary_paid, 0, var_work_days, r_emp.eid);
return next;

else -- is part-time
-- count total working hours
select sum(end_time - start_time) into var_work_hours from sessions s where s.instructor = r_emp.eid;
-- calculate salary
var_hourly_rate := r_emp.hourly_rate;
var_salary_paid := var_work_hours * var_hourly_rate;
var_eid := r_emp.eid;
var_name := r_emp.name;
var_status := 'part-time';
var_work_days := null;
var_monthly_salary = null;
insert into pay_slips values (current_date, var_salary_paid, var_work_hours, 0, var_eid);
return next;
end if;
end loop;
close curs_emp;
END;                
$$ LANGUAGE plpgsql;




/*
proc 26
promote_courses: This routine is used to identify potential course offerings that could be of interest to inactive customers. 
Returns a table of records of information for each inactive customer: 
	customer identifier, 
	customer name, 
	course area A that is of interest to the customer, 
	course identifier of a course C in area A, 
	course title of C, 
	launch date of course offering of course C that still accepts registrations, 
	course offering’s registration deadline,
	and fees for the course offering. 
sorted in ascending order of customer identifier and course offering’s registration deadline.
A customer is classified as an active customer if the customer has registered 
for some course offering in the last six months (inclusive of the current month); 
otherwise, the customer is considered to be inactive customer. 
ok
A course area A is of interest to a customer C if there is some course offering in area A 
among the three most recent course offerings registered by C. 
If a customer has not yet registered for any course offering, 
we assume that every course area is of interest to that customer. 
*/
CREATE OR REPLACE FUNCTION promote_courses()
RETURNS Table (
  out_cust_id INT, 
  out_cust_name TEXT, 
  out_course_area Varchar(50), 
  out_course_id INT, 
  out_course_title Varchar(50), 
  out_launch_date DATE, 
  out_registration_deadline DATE, 
  out_fee FLOAT)
AS $$
BEGIN
RETURN QUERY(
  WITH Cust AS( -- cust_id,    at date,   register course_id
    select distinct cust_id, register_date as from_date, course_id from Registers
    UNION
    select distinct cust_id, date as from_date, course_id from Redeems
  ),
  CustN AS( -- cust_id, cust_name, at reg_date, register course_id
    select distinct cust_id, name as cust_name, from_date as reg_date, course_id
    from Customers NATURAL JOIN Credit_cards NATURAL LEFT JOIN Cust --那些啥都没买的也join进来保留下来了，他们注册credit_card的时候
  ),
  Inactive AS( -- cust_id, cust_name, at reg_date, register course_id; but not within recent 6 months
    select cust_id, cust_name, reg_date, course_id
    from CustN CN
    where NOT EXISTS(
      select 1
      from CustN CN2
      where CN2.cust_id = CN.cust_id
        AND CN2.reg_date BETWEEN (CURRENT_DATE - INTERVAL '6 month')::DATE AND CURRENT_DATE
    )
  ),
  Recent3 AS( -- only the recent 3 records left -- cust_id, cust_name, reg_date, course_id
    select *
    from Inactive I1
    where (select count(*) from Inactive I2 WHERE I2.cust_id = I1.cust_id AND I2.reg_date > I1.reg_date) < 3 -- no more than 3 greater than
  ),
  Areas AS( -- join Courses, find course_area and course_title, need to separate two class of customers
    -- 这一步核心目的只要得到cust_id 和 对应的area就好。保留cust_name用以避免下一步再join一次customers
    (select * from
      (select cust_id, cust_name from Recent3 R3 where R3.course_id IS NULL) A,
      (select area from Courses) B -- cross product, pair up every customer who has no buy with every course area
    ) --这里不要该名成course_area，因为之后natural join必须要用area
    UNION
    (select cust_id, cust_name, area -- 不要course_id，因为有的是null。之后用area去join，反过来得到符合的course_id
    from Recent3 NATURAL JOIN Courses
    )
  )
  select cust_id as out_cust_id, 
         cust_name as out_cust_name, 
         area as out_course_area, 
         course_id as out_course_id, 
         title as out_course_title, 
         launch_date as out_launch_date, 
         registration_deadline as out_registration_deadline, 
         fees as out_fee
  from Areas NATURAL JOIN Courses NATURAL JOIN Offerings
  where registration_deadline > CURRENT_DATE
  order by cust_id, registration_deadline asc
);  
END;
$$ LANGUAGE plpgsql;
											     
--     select *
--     from Inactive
--     group by cust_id
--     order by reg_date desc
--     limit 3
-- 注意：select的* 必须要么是primary key，要么是在group by里面出现，要么在aggregation里

-- proc 27: checked
CREATE OR REPLACE FUNCTION top_packages (N INTEGER)
RETURNS TABLE (package_id TEXT, free_session INTEGER, price FLOAT, 
start_date DATE, end_date DATE, sold INTEGER) AS $$
DECLARE
    curs CURSOR FOR (SELECT C.package_id, C.num_free_registrations, C.price, C.sale_start_date, C.sale_end_date, COUNT(*) as sold
                      FROM course_packages C NATURAL LEFT JOIN buys B
                      -- check if the package’s start date is within this year, and is bought in this year
                      WHERE EXTRACT(YEAR FROM C.sale_start_date) = EXTRACT(YEAR FROM CURRENT_DATE) 
                      and EXTRACT(YEAR FROM B.date) = EXTRACT(YEAR FROM CURRENT_DATE)
                      GROUP BY C.package_id
                      ORDER BY sold desc, price desc);
    r RECORD;
    i INTEGER; 
    last_sold INTEGER;
    last_price FLOAT;
    leave_or_not INTEGER;
BEGIN
    i := 1;
    OPEN curs;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        sold := r.sold;
        price := r.price;
        
        IF (i > N) and NOT(last_sold = sold and last_price = price)
        THEN
            leave_or_not := 1;
        ELSE
            leave_or_not := 0;
        END IF;
        EXIT WHEN (leave_or_not = 1);
        
        package_id := r.package_id;
        free_session := r.num_free_registrations;
        start_date := r.sale_start_date;
        end_date := r.sale_end_date;
        RETURN NEXT;
        -- reserve this no. of sold and price fro comparison 
        last_sold := sold;
        last_price := price;
        i := i + 1;
    END LOOP;
    CLOSE curs;

END;
$$ LANGUAGE plpgsql;
							       
-- proc 28: checked
CREATE OR REPLACE FUNCTION popular_courses ()
RETURNS TABLE (course_id INTEGER, course_title TEXT, course_area VARCHAR(50), 
num_offer INTEGER, latest_offer_registration INTEGER) AS $$
DECLARE
    curs CURSOR FOR ( SELECT R.course_id, R.title, R.area, R.launch_date, R.start_date, 
                             (COALESCE (num_redeem, 0)+COALESCE (num_register, 0)-COALESCE (num_cancel, 0)) as num_registrations
                      FROM (courses C 
                      NATURAL LEFT JOIN offerings O
                      NATURAL LEFT JOIN  
                      (SELECT R1.course_id, R1.launch_date, COUNT(*) AS num_redeem
                        FROM redeems R1 
                        GROUP BY R1.course_id, R1.launch_date) AS redeem_info
                        
                      NATURAL LEFT JOIN   
                      (SELECT R2.course_id, R2.launch_date, COUNT(*) AS num_register
                        FROM registers R2 
                        GROUP BY R2.course_id, R2.launch_date) AS register_info
                        
                      NATURAL LEFT JOIN 
                      (SELECT R3.course_id, R3.launch_date, COUNT(*) AS num_cancel
                        FROM cancels R3 
                        GROUP BY R3.course_id, R3.launch_date) AS cancel_info) AS R
                      -- check if offerings’s start date is within this year
                      WHERE EXTRACT(YEAR FROM R.start_date) = EXTRACT(YEAR FROM CURRENT_DATE) 
                      ORDER BY R.course_id, R.start_date);
    r RECORD;
    count INTEGER; 
    return_or_not INTEGER;
BEGIN
    count := 1;
    return_or_not := 1;
    
    OPEN curs;
    FETCH curs INTO r;
    course_id := r.course_id;
    course_title := r.title;
    course_area := r.area;
    latest_offer_registration := r.num_registrations;
    LOOP
        FETCH curs INTO r;
        EXIT WHEN NOT FOUND;
        -- if they have the same course_id, but ealier one has a higher number of registrations
        -- update the return_or_not to be 0, this is for the situation that
        -- if next pair has the same course_id but does not violate the rule, the later one still cannot be returned 
        IF (course_id = r.course_id) and (latest_offer_registration >= r.num_registrations) 
        THEN
            return_or_not := 0;
        -- if they have the same course_id, but some previous pair violate the rule, then it cannot be returned 
        ELSIF (course_id = r.course_id) and (return_or_not = 0)
        THEN
            count := 1;
            return_or_not := 0;
        -- if they have the distinct course_id, but the previous course is not returned
        ELSIF NOT(course_id = r.course_id) and (return_or_not = 0)
        THEN
            count := 1;
            return_or_not := 1;
        ELSIF NOT(course_id = r.course_id) and (return_or_not = 1) and (count = 1)
        THEN
            return_or_not := 1;
        -- if they have the distinct course_id, and the previous course is popular then return
        ELSIF NOT(course_id = r.course_id) and (return_or_not = 1) and (count > 1)
        THEN
            count := 1;
            return_or_not := 1;
            RETURN NEXT;
        -- if same course_id and no violation 
        ELSE
            count := count + 1;
        END IF;
        -- update the course offering info
        course_id := r.course_id;
        course_title := r.title;
        course_area := r.area;
        num_offer := count;
        latest_offer_registration := r.num_registrations;
    END LOOP;
    IF (return_or_not = 1) and (count > 1) 
    THEN
        RETURN NEXT;
    END IF;
    CLOSE curs;

END;
$$ LANGUAGE plpgsql;				       
			      
-- proc 29: checked			      
CREATE OR REPLACE FUNCTION view_summary_report(N INTEGER)
RETURNS TABLE(month INTEGER, year INTEGER, salaries INTEGER, num_packages INTEGER, 
registration_fees FLOAT, refund FLOAT, num_redeems INTEGER) AS $$
DECLARE 
    i INTEGER;
    cur_date DATE;
BEGIN
    -- cur_date is the date of the 1st day of the current month 
    -- Cuz later need to do minus INTERVAL '1 month', if today is 03-31, things will get complicated
    cur_date := DATE_TRUNC('MONTH', NOW())::DATE;
    i := 1;
    LOOP
        EXIT WHEN i > N;
        month := EXTRACT(MONTH FROM cur_date);
        year := EXTRACT(YEAR FROM cur_date);
        
        -- in case sum(amount) = null
        SELECT COALESCE (SUM(amount), 0) INTO salaries
        FROM pay_slips
        WHERE month = EXTRACT(MONTH FROM payment_date) and year = EXTRACT(YEAR FROM payment_date);
        -- COUNT(*) will be 0 if empty
        SELECT COUNT(*) INTO num_packages
        FROM buys
        WHERE month = EXTRACT(MONTH FROM date) and year = EXTRACT(YEAR FROM date);
        -- in case sum(fees) = null
        SELECT COALESCE (SUM(fees), 0) INTO registration_fees
        FROM registers R NATURAL JOIN offerings
        WHERE month = EXTRACT(MONTH FROM R.register_date) and year = EXTRACT(YEAR FROM R.register_date);
        -- in case sum(refund_amt) = null
        SELECT COALESCE (SUM(refund_amt), 0) INTO refund
        FROM cancels
        WHERE month = EXTRACT(MONTH FROM cancel_date) and year = EXTRACT(YEAR FROM cancel_date);
        -- COUNT(*) will be 0 if empty
        SELECT COUNT(*) INTO num_redeems
        FROM redeems
        WHERE month = EXTRACT(MONTH FROM date) and year = EXTRACT(YEAR FROM date);

        RETURN NEXT;
        i := i + 1;
        cur_date:= cur_date - INTERVAL '1 month';
    END LOOP;
END;
$$ LANGUAGE plpgsql;			      
			      
			      
			      
			     
-- proc 30: checked
create or replace function fees_by_manager(input_eid integer)
returns table(var_course_id integer, var_fee integer) as $$
declare
curs cursor for (select c.course_id from courses c, course_areas ca where c.area = ca.name and manager_eid = input_eid);
r record;
begin
open curs;
loop
fetch curs into r;
exit when not found;
var_course_id := r.course_id;
var_fee := (select sum(fees) from registers reg, offerings o where o.course_id = r.course_id and o.course_id = reg.course_id and o.launch_date = reg.launch_date and extract(year from o.end_date) = extract(year from current_date))
+ coalesce((select sum(price / num_free_registrations) from redeems red, course_packages cp, offerings o where extract(year from o.end_date) = extract(year from current_date) and o.course_id = r.course_id and o.course_id = red.course_id and o.launch_date = red.launch_date and red.package_id = cp.package_id), 0);
return next;
end loop;
close curs;
end;
$$ language plpgsql;

create or replace function view_manager_report()
returns table(var_name text, var_num_course_areas integer, var_num_course_offerings integer, var_total_fee integer, var_title varchar(50)) as $$
declare
curs_manager cursor for (select e.name, e.eid from managers m natural join employees e order by e.name);
r record;
var_num_ties integer;
begin
open curs_manager;
loop
fetch curs_manager into r;
exit when not found;
with fees_this_manager as (select * from fees_by_manager(r.eid))
select count(distinct var_course_id) into var_num_ties from fees_this_manager where var_fee = (select max(var_fee) from fees_this_manager);
loop
exit when var_num_ties = 0;
var_name := r.name;
var_num_course_areas := (select count(distinct name) from course_areas where manager_eid = r.eid);
var_num_course_offerings := (with fees_this_manager as (select * from fees_by_manager(r.eid)) select count(distinct var_course_id) from fees_this_manager);
var_total_fee := (with fees_this_manager as (select * from fees_by_manager(r.eid)) select sum(var_fee) from fees_this_manager);
var_title := (with fees_this_manager as (select * from fees_by_manager(r.eid)) select title from fees_this_manager, courses where var_course_id = course_id and var_fee = (select max(var_fee) from fees_this_manager) offset var_num_ties-1 limit 1);
var_num_ties := var_num_ties - 1;
return next;
end loop;
end loop;
close curs_manager;
end;
$$ language plpgsql;
